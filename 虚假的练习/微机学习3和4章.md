## 1

指令的操作数有  

- A.立即数
- B.寄存器操作数
- C.存储器操作数
- D.以上都是

D

## 2

存储器操作数可以是     。

得分/总分

- A.字节类型
- B.字类型
- C.双字类型
- D.以上都是

D

## 3

单选(1分)

能作为间接寻址使用的寄存器有     //寄存器间接寻址是将指定的寄存器内容为地址，由该地址所指定的单元内容作为操作数。

- A.AX, BX, CX, DX
- B.CS, DS, SS, ES
- C.BX, SI, DI,BP
- D.IP ,BP, SP, SS

C

>操作数在寄存器中，操作数有效地址在SI、DI、BX、BP这四个寄存器之一中。在一般情况下，如果有效地址在SI、DI和BX中，则以DS段寄存器中的内容为段值。如果有效地址在BP中，则以SS段寄存器中的内容为段值

------

通用寄存器:

  数据寄存器:

  AH(8位)  AL(8位)  AX(16位)   (AX和AL又称累加器)

  BH(8位)  BL(8位)  BX(16位)   (BX又称基址寄存器,唯一作为存储器指针使用寄存器)  

  CH(8位)  CL(8位)  CX(16位)   (CX用于字符串操作，控制循环的次数,CL用于移位)

  DH(8位)  DL(8位)  DX(16位)   (DX一般用来做32位的乘除法时存放被除数或者保留余数)

 

  指针寄存器:

  SP 堆栈指针 (存放栈顶地址)

  BP 基址指针 (存放堆栈基址偏移)

 

  变址寄存器:主要用于存放某个存储单元地址的偏移,或某组存储单元开始地址的偏移,

  即作为存储器(短)指针使用。作为通用寄存器,它们可以保存16位算术逻辑运算中的操

  作数和运算结果,有时运算结果就是需要的存储单元地址的偏移.

 

  SI 源地址  (源变址寄存器)

  DI 目的地址 (目的变址寄存器)

  

控制寄存器:

  IP 指令指针

  FLAG 标志寄存器

  　① 进位标志　CF，记录运算时最高有效位产生的进位值。

 ② 符号标志　SF，记录运算结果的符号。结果为负时置1，否则置0。

 ③ 零标志　　ZF，运算结果为0时ZF位置1，否则置0。

 ④ 溢出标志　OF，在运算过程中，如操作数超出了机器可表示数的范围称为溢出。溢出时OF位置1，否则置0。

 ⑤ 辅助进位标志　AF，记录运算时第3位（半个字节）产生的进位值。

 ⑥ 奇偶标志　PF，用来为机器中传送信息时可能产生的代码出错情况提供检验条件。当结果操作数中1的个数为偶数时置1，否则置0。

 

段寄存器

  CS 代码段  IP

  DS 数据段  

  SS 堆栈段  SP BP

  ES 附加段

 

七种寻址方式:

1、立即寻址方式:

操作数就包含在指令中。作为指令的一部分，跟在操作码后存放在代码段。

这种操作数成为立即数。立即数可以是8位的，也可以是16位的。

例如:

    指令: MOV AX,1234H
    
      则: AX = 1234H

 




2、寄存器寻址方式:

操作数在CPU内部的寄存器中，指令指定寄存器号。

对于16位操作数，寄存器可以是:AX、BX、CX、DX、SI、DI、SP和BP等。

对于8位操作数，寄存器可以是AL 、AH、BL、BH、CL、CH、DL、DH。

这种寻址方式由于操作数就在寄存器中,不需要访问存储器来取得操作数

因而可以取得较高的运算数度。

 

3、直接寻址方式:

操作数在寄存器中，指令直接包含有操作数的有效地址(偏移地址)

注：操作数一般存放在数据段

所以操作数的地址由DS加上指令中直接给出的16位偏移得到。如果采用

段超越前缀，则操作数也可含在数据段外的其他段中。

例如:

MOV AX,[8054]

如(DS) = 2000H,

则执行结果为(AX) = 3050H

(物理地址=20000+8054=28054H)

28054H里的内容为3050H

 

在汇编语言指令中，可以用符号地址代替数值地址

如:MOV AX,VALUE

此时VALUE为存放操作数单元的符号地址。

如写成:MOV AX,[VALUE]也是可以的，两者是等效的。

如VALUE在附加段中，则应指定段超越前缀如下:

MOV AX,ES:VALUE 或 MOV AX,ES:[VALUE]

 

4、寄存器间接寻址方式:

操作数在寄存器中，操作数有效地址在SI、DI、BX、BP

这四个寄存器之一中。在一般情况下，如果有效地址在

SI、DI和BX中，则以DS段寄存器中的内容为段值。如果

有效地址在BP中，则以SS段寄存器中的内容为段值

例如:

MOV AX,[SI]

如果(DS) = 5000H (SI) = 1234H

则物理地址 =  50000 + 1234 = 51234H

51234H地址中的内容为:6789H

执行该指令后,(AX) = 6789H

 

5、寄存器相对寻址方式:

操作数在存储器中，操作数的有效地址是一个基址寄存器(BX、BP)

或变址寄存器(SI、DI)的内容加上指令中给定的8位或16位位移量之和

 

    BX  8位 位移量

EA(有效地址) =  BP  + 

    SI  16位 位移量
    
    DI

在一般情况下，如果SI、DI、或BX中的内容作为有效地址的一部分，那么

引用的段寄存器是DS;如果BP中的内容作为有效地址的一部分，那么引用的

段寄存器是SS。

 

物理地址 = 16d × (DS) + (BX) + 8

           或(SI)或16位位移量
    
           或(DI)

物理地址 = 16d × (SS) + (BP) + 8位位移量

                       或16位位移量

在指令中给定的8位或16位位移量采用补码形式表示。在计算有效地址时，如

位移量是8位，则被带符号扩展成16位。

例如:

MOV AX,[DI+1223H]

假设，(DS) = 5000H，(DI) = 3678H

则物理地址 = 50000 + 3678 + 1233 = 5489BH

5489BH地址中的内容:55AAH

执行该指令后AX = 55AAH

下面指令中，源操作数采用寄存器相对寻址，引用的段寄存器是SS: MOV BX,[BP-4]

下面指令中，目的操作数采用寄存器相对寻址，引用的段寄存器是ES: MOV ES:[BX+5],AL

指令:MOV AX,[SI+3]与MOV AX,3[SI]是等价的

 

6、基址加变址寻址方式:

操作数在寄存器中，操作数的有效地址由:

基址寄存器之一的内容与变址寄存器之一的内容相加

   BX   SI

即: EA =    + 

   BP   DI

在一般情况下，如果BP之内容作为有效地址的一部分，则以SS之内容为段值，否则已DS

为段值。

例如：

MOV AX,[BX][DI]

如:(DS)=2100H,

   (BX)=0158H,

   (DI)=10A5H

则EA=0158 + 10A5 = 11FD

物理地址=21000 + 11FD = 221FDH

221FDH地址中的内容:1234H

执行该指令后AX = 1234H

 

下面指令中，目的操作数采用基址加变址寻址，

引用的段寄存器是DS: MOV DS:[BP+SI],AL

 

下面指令中，源操作数采用基址加变址寻址，

引用的段寄存器ES: MOV AX,ES:[BX+SI]

 

这种寻址方式使用与数组或表格处理。用基址寄存器存放数组首地址，而用变地寄存器

来定位数组中的各元素，或反之。由于两个寄存器都可改变，所以能更加灵活地访问数

组或表格中的元素。

下面的两种表示方法是等价的:

MOV AX,[BX+DI]

MOV AX,[DI][BX]

 

7、相对基址加变址寻址方式：

操作数在存储器中，操作数的有效地址由于基址寄存器之一的内容与变址寄存器之一的

内容及指令中给定的8位或16位位移量相加得到。

         BX    SI    8位

即: EA =     +     +      位移量

   BP    DI    16位

在一般情况下，如果BP中的内容作为有效地址的一部分，则以SS段寄存器中的内容为段

值，否则以DS段寄存器中的内容为段值。

在指令中给定的8位或16位位移量采用补码形式表示。

在计算有效地址时，如果位移量是8位，那么被带符号扩展成16位。

当所得的有效地址操作FFFFH时，就取其64K的模

例如:

MOV AX,[BX+DI-2]

假设，(DS) = 5000H, (BX) = 1223H, DI = 54H, (51275) = 54H, (51276) = 76H

物理地址= 50000 + 1223 + 0054 + FFFE(-2 各位取反末位加一) = 51275H

执行该指令后 (AX) = 7654H

 

相对基址加变址这种寻址方式的表示方法多种多样，以下四种方法均是等价的：

MOV AX,[BX+DI+1234H], MOV AX,1234H[BX][DI]

MOV AX 1234H[BX+DI],  MOV AX,1234H[DI][BX]

------

## 4

WORD PTR [SI] 表示     。

- A.字类型的操作数（16位二进制数）
- B.字节类型的操作数（8位二进制数）
- C.双字类型的操作数（32位二进制数）
- D.64位二进制数

A

## 5

单选(1分)

存储器操作数的可用寻址方式有     。

- A.直接寻址和间接寻址
- B.相对寻址
- C.基址变址寻址和基址变址相对寻址
- D.以上都是

D

## 6

内存中有名为table的一维数组，若想存取其中的任意数据，常采用     

- A.存储器直接寻址方式
- B.存储器间接寻址方式
- C.相对寻址方式
- D.基址变址寻址方式

C

 <u>D、基址变址也是常用的方式</u>

7

MOV  AX, [BX+SI] 的指令中，源操作数的物理地址应该如何计算？

- A.BX+SI
- B.DS*10H+BX+SI
- C.ES*10H+BX+SI
- D.SS*10H+BX+SI

B

## 8

MOV  AX, 29 指令中源操作数的寻址方式是     。

- A.直接寻址
- B.间接寻址
- C.立即寻址
- D.寄存器寻址

C

## 9

单选(1分)

二维数组中，常常采用哪种寻址方式？

- A.间接寻址
- B.相对寻址
- C.基址变址寻址
- D.基址变址相对寻址

DB

## 10

MOV AX,TABLE[BP][SI] 的指令中，源操作数默认的段基址是     。

- A.DS
- B.ES
- C.SS
- D.CS

C

## 11

把数据100存入[SI]指明的存储单元中，请写出指令。

正确答案：MOV  BYTE PTR [SI], 100

## 12

把AX压入堆栈，请写出指令。

正确答案：PUSH AX

## 13

从03F8H端口中输入一个数据（8位）, 请写出指令。

正确答案：MOV DX, 03F8H
IN AL,DX

## 14

从40H端口中输出一个数据（8位）, 请写出指令。

正确答案：OUT 40H, AL

## 15

将AL和BL中的数据相加，请写出指令。

正确答案：ADD AL,BL

## 16

比较AX和BX的值，请写出指令。

正确答案：CMP AX, BX

## 17

测试AX中第0位的值，请写出指令。

正确答案：TEST AX, 01H

## 18

AX=39H, 执行AND AL, OFH 指令后，AL=?

正确答案：9

## 19

执行LOOP TABLE指令时，CX=33, 程序接下来执行哪的指令？

正确答案：TABLE：

## 20

过程调用和返回指令是什么？

正确答案：CALL  RET

## 设计题

2. BUFF为字节类型变量，DATA为常量，指出下列指令中源操作数的寻址方式

（1）MOV AX, 1200                  //立即寻址

（2）MOV AL, BUFF                //直接寻址   

（3）SUB BX, [2000H]          //直接寻址

（4）MOV CX, [SI]                //寄存器间接寻址

（5）MOV DX, DATA[SI]       //寄存器相对寻址

（6）MOV BL, [SI][BX]        //基址变址寻址

（7）MOV [DI], AX          //寄存器寻址

（8）ADD AX, DATA[DI+BP]       //基址变址寻址相对寻址

（9）PUSHF                              //隐含寻址

（10）  MOV BX, ES:[SI]        //寄存器间接寻址




3. 指出下列指令的错误并改正。




（1）MOV DS, 1200   //不能用立即数给段基址赋值

（2）MOV AL, BL         // 操作数类型不一样

（3）SUB 33H, AL          //立即数不能作为目的操作数

（4）PUSH AX             //压栈指令操作数必须是字类型

（5）MUL 45H            // 操作数不能是立即数

（6）MOV [BX], [SI]     //源操作数和目的操作数不能都是内存操作数

（7）MOV [DI], 3        //目的变址寄存器不能进行立即数操作

（8）ADD DATA[DI+BP], ES:[CX]          //cx不能作为间址寄存器使用

（9）JMP BYTE PTR[SI]            //源的操作数为字类型

（10）  OUT F8H, AL           //16位的端口地址不能直接在输入指令中使用




4. 根据要求写出一条（或几条）汇编语言指令。

（1）将立即数4000H送入寄存器BX。

```ASN.1
MOV BX 4000H
```

（2）将立即数4000H送入段寄存器DS。

```
MOV AX 4000H
MOV DS AX
```

（3）将变址寄存器DI的内容送入数据段中2000H的存储单元。

```
MOV [2000H] DI
```

（4）把数据段中2000H存储单元的内容送段寄存器ES。

```
MOV AX [2000H]
MOV ES AX
```

（5）将立即数3DH与AL相加，结果送回AL。

```
ADD AL,3DH
```

（6）把BX与CX寄存器内容相加，结果送入BX。

```
ADD BX CX 
```

（7）寄存器BX中的低4位内容保持不变,其他位按位取反，结果仍在BX中。

```
MOV AX,BX
NOT AX
AND AX,OFFF0H
AND BX,OOOFH
OR BX,AX
```

（8）实现AX与-128的乘积运算。

```
MOV BX -128
IMUL BX
```

（9）实现AX中高、低8位内容的交换。

```
MOV AL,8
ROL CX AL
```

（10）  将DX中D0、D4、D8位置1，其余位保持不变。

```
OR DX,0111H
```

5. 设SS=2000H，SP=1000H，SI=2300，DI=7800，BX=9A00H。说明执行下面每条指令时，堆栈内容的变化和堆栈指针的值。

PUSH SI

PUSH DI

POP BX

```
PUSH SI
(OFFFH)=23H
0FFEH=00H
SP=0FFEH
PUSH DI
(OFFDH)=78H
(OFFCH)=00H
SP=0FFCH
POP BX
BX=7800H

```

6. 内存中18FC0H、18FC1H、18FC2H单元的内容分别为23H、55、5AH，DS=1000H，BX=8FC0H，SI=1，执行下面两条指令后AX=？DX=?

MOV AX, [BX+SI] 

LEA DX, [BX+SI]



7. 回答下列问题：

（1）设AL=7FH，执行CBW指令后，AX=?

CBW 字节转换为字指令执行的操作：AL的内容扩展到AH,形成AX中的字。
AL符号扩展为AX。在8086中CBW指令将AL的最高有效位D7扩展至AH，即：如果AL的最高有效位是0，则AH = 00，AL的最高有效位为1，则AH = FFH。AL不变。（即将AL的符号位移至AH）

（2）设AX=8A9CH，执行CWD指令后，AX=？DX=?

AX=8A9CH; DX=FFFFH;

8. 执行以下两条指令后，FLAGS的6个状态标志位的值是什么？

MOV AX, 847BH

ADD AX, 9438H

 CF=1;AF=0;OF=1;ZF=0;SF=0;

10、用串操作指令替换以下程序段：

ABC：MOV  AL, [SI]

   MOV  ES:[DI], AL

   INC SI

   INC DI

​    LOOP ABC



12、试写出执行下列3条指令后BX寄存器的内容。

MOV CL，2H

MOV BX，CO2DH

SHR BX，CL

BX=300BH;

14. 编写程序段，实现下述要求：

使AX寄存器的低4位清0，其余位不变。

AND AX OFFFOH

使BX寄存器的低4位置1，其余位不变。

AND AX OFH

测试AX的第0位和第4位，两位都是1时将AL清0。

&#8194;TEST&#8194;AX,01H&#8194;

JZ&#8194;&#8194;&#8194;AA

&#8194;TEST&#8194;&#8194;AX,10H

&#8194;JZ&#8194;&#8194;AA&#8194;MOV&#8194;AL,0&#8194;

HLT

&#8194;AA:&#8194;......&#8194;&#8194;

测试AX的第0位和第4位，两位中有一个为1时将AL清0

&#8194;TEST&#8194;AX,&#8194;11H

&#8194;JZ&#8194;AA&#8194;

MOV&#8194;AL,0&#8194;

AA:&#8194;......